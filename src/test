
#include "minishell.h"

void	*get_next_token(void *node)
{
	if (!node)
		return (NULL);
	return (((t_token *)node)->next);
}

void	*get_next_cmds(void *node)
{
	if (!node)
		return (NULL);
	return (((t_cmds *)node)->next);
}

void	*get_next_word(void *node)
{
	if (!node)
		return (NULL);
	return (((t_word *)node)->next);
}

void	*get_next_redir(void *node)
{
	if (!node)
		return (NULL);
	return (((t_redir *)node)->next);
}/*
*/

#include "libft.h"
#include "minishell.h"
#include <unistd.h>


t_fragment *create_fragment(char *text, int quote_type)
{
	t_fragment *new = malloc(sizeof(t_fragment));
	if (!new)
		return (NULL);
	new->text = text;
	new->quote_type = quote_type;
	new->next = NULL;
	return (new);
}

void append_fragment(t_fragment **head, t_fragment *new)
{
	t_fragment *tmp;

	if (!*head)
	{
		*head = new;
		return;
	}
	tmp = *head;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new;
}

t_fragment *build_word(const char *str, int *i)
{
	t_fragment *frags = NULL;
	char *segment;
	int start;
	int qt;

	while (str[*i] && !is_separator(str[*i]))
	{
		qt = NO_QUOTE;
		if (str[*i] == '"')
		{
			qt = DOUBLE_QUOTE;
			(*i)++;
			start = *i;
			while (str[*i] && str[*i] != '"')
				(*i)++;
			segment = ft_substr(str, start, *i - start);
			if (str[*i]) (*i)++;
		}
		else if (str[*i] == '\'')
		{
			qt = SINGLE_QUOTE;
			(*i)++;
			start = *i;
			while (str[*i] && str[*i] != '\'')
				(*i)++;
			segment = ft_substr(str, start, *i - start);
			if (str[*i]) (*i)++;
		}
		else
		{
			start = *i;
			while (str[*i] && !is_separator(str[*i]) && str[*i] != '"' && str[*i] != '\'')
				(*i)++;
			segment = ft_substr(str, start, *i - start);
		}
		append_fragment(&frags, create_fragment(segment, qt));
	}
	return frags;
}




int is_word_start(char c)
{
    return (c && !is_separator(c));
}

char *token_to_string(t_token *token)
{
	t_fragment *frag = token->fragments;
	char *result = ft_strdup("");
	char *tmp;

	while (frag)
	{
		tmp = result;
		result = ft_strjoin(result, frag->text);
		free(tmp);
		frag = frag->next;
	}
	return result;
}

t_token	*ft_input(char *string)
{
	int i = 0;
	t_token *head = NULL;

	while (string[i])
	{
		// Ignore les espaces
		while (ft_isspace(string[i]))
			i++;
		// Gere "" et '' et les enchainements
		if (is_word_start(string[i]))
		{
			t_fragment *frags = build_word(string, &i);
			if (!frags)
				return (NULL);
			ft_create_token(WORD, frags, &head);
		}
		else if (string[i] == '|')
		{
			t_fragment *frag = create_fragment(ft_strdup("|"), NO_QUOTE);

			ft_create_token(PIPE, frag, &head);
			i++;
		}
		else if (string[i] == '>' && string[i + 1] == '>')
		{
			t_fragment *frag = create_fragment(ft_strdup(">>"), NO_QUOTE);
			ft_create_token(APPEND, frag, &head);
			i += 2;
		}
		else if (string[i] == '<' && string[i + 1] == '<')
		{
			t_fragment *frag = create_fragment(ft_strdup("<<"), NO_QUOTE);

			ft_create_token(HEREDOC, frag, &head);
			i += 2;
		}
		else if (string[i] == '<')
		{
			t_fragment *frag = create_fragment(ft_strdup("<"), NO_QUOTE);

			ft_create_token(REDIR_IN, frag, &head);
			i++;
		}
		else if (string[i] == '>')
		{
			t_fragment *frag = create_fragment(ft_strdup(">"), NO_QUOTE);
			ft_create_token(REDIR_OUT, frag, &head);
			i++;
		}
	}
	return (head);
}


#include "minishell.h"

int ft_strcmp(char *s1, char *s2)
{
	int i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
	{
		i++;
	}
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int return_empty(t_token *token)
{
	char *value = token_to_string(token);
	int result = (!ft_strcmp(value, ":") || !ft_strcmp(value, "!"));
	free(value);
	return result;
}

int lexer_parse(t_token *token)
{
	// que des espaces
	if (token == NULL)
	{
		return (0);
	}
	if (return_empty(token))
	{
		return (0);
	}
	// ne peut peut pas commencer par un pipe
	if (token->type == PIPE)
	{
		ft_printf("Error: syntax error near unexpected token `|'\n"); //
		return (0);													  //
	}
	while (token != NULL)
	{
		if (token->next != NULL)
		{
			// pas de double ||
			if (token->type == PIPE && token->next->type == PIPE)
			{
				ft_printf("Syntax error || detected\n");
				return (0); //
			}
		}
		// ne peut pas terminer par un |
		if (token->type == PIPE && token->next == NULL)
		{
			ft_printf("Syntax error end with a | not allowed\n");
			return (0);
		}
		// verifie ce qu'il y a apres une redir
		if (is_redir(token))
		{
			if (token->next == NULL)
			{
				ft_printf("bash: syntax error near unexpected token `newline'\n");
				return (0);
			}
			if (token->next->type != WORD)
			{
				ft_printf("bash: syntax error near unexpected redir\n");
				return (0);
			}
		}
		char *val = token_to_string(token);
		ft_printf("Type is: %d, value is %s, index is %i\n",
			token->type, val, token->index);
		free(val);

		token = token->next;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: abonifac <abonifac@student.42lyon.fr>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 08:24:15 by ehosta            #+#    #+#             */
/*   Updated: 2025/03/30 17:22:50 by abonifac         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <readline/history.h>
#include <readline/readline.h>
#include <stdio.h>
#include <strings.h>

int	main(void)
{
	char	*line;
	t_token	*token;

	token = NULL;
	// char	**map;
	while (1)
	{
		set_sig_action();
		line = readline("minishell$ ");
		// Gere la sortie propre avec CTRL D
		if (!line)
		{
			ft_printf("exit\n");
			break ;
		}
		token = ft_input(line);
		if (!lexer_parse(token))
		{
			free(line);
			token_clear(&token, del_token);
		}
		else
		{
			parser(token);
			free(line);
			token_clear(&token, del_token);
		}
		// lst_clear((void **)head, get_next_cmds, del_cmds);
	}
	return (0);
}

// cd ls -e "coucou'bon|jour'" 'bonjour"cou>cou"' | > >> < <<


// Si je commence par un pipe : erreur
// Si je trouve une redirection : il faut que je trouve un mot juste après
// Deux pipes qui se suivent : erreur
// Si je termine par un pipe : erreur
// Les quotes fermées : déjà gérées dans le lexer normalement,
// donc le parser est clean là-dessus

// Tu pars du début de la liste des tokens
// Tant que ce n’est pas un pipe ou la fin :
// Si c’est un WORD et que t’as pas de commande : c’est ta commande
// Si c’est un WORD et que la commande est là : c’est un argument
// Si c’est une redirection : tu vérifies qu’il y a un WORD derrière : sinon erreur
// Si tu tombes sur un pipe : tu vérifies que t’as bien eu une commande avant : tu passes à la suite
// Si la liste se termine : tu vérifies que la dernière commande était valide

#include "minishell.h"

void create_cmds(t_token *head_token, t_token *end, t_cmds **head);

int parser(t_token *head)
{
	t_token *tmp;
	t_cmds *head_cmd;
	t_token *start;

	tmp = head;
	head_cmd = NULL;
	// si on fait entrer renvoie le prompt
	if (tmp == NULL)
		return (0); //
	// permet de retourner en arriere pour lire du debut jusqu au | ou NULL
	start = head;
	// on parcourt la liste
	while (tmp != NULL)
	{
		// on cree une commande entre start et end
		if (tmp->type == PIPE || tmp->next == NULL)
		{
			create_cmds(start, tmp, &head_cmd);
			start = tmp->next;
		}
		tmp = tmp->next;
	}
	return (0);
}

void append_word(t_word **head, t_word *new)
{
	t_word *tmp;

	if (!*head)
	{
		*head = new;
		return;
	}
	tmp = *head;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new;
}

void create_word(t_cmds *cmd, t_token *token)
{
	t_word *new;
	t_word *tmp;

	tmp = cmd->words;
	new = malloc(sizeof(t_word));
	if (!new)
	{
		cmd->leak_flag = 1;
		return (perror("Malloc failed")); // return Success mais normal, il faut faire echouer avec -1
	} //
	ft_memset(new, 0, sizeof(t_word));
	new->word = token_to_string(token);
	if (!new->word)
	{
		cmd->leak_flag = 1;
		free(new);
		return (perror("Malloc failed")); //
	}
	t_fragment *first = token->fragments;
	new->quote_type = (first ? first->quote_type : NO_QUOTE);
	append_word(&cmd->words, new);
	// ft_printf("Create word: %s quote_type %i\n", new->word, new->quote_type);
}

void append_redir(t_redir **head, t_redir *new)
{
	t_redir *tmp;

	if (!*head)
	{
		*head = new;
		return;
	}
	tmp = *head;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new;
}

void create_redir(t_cmds *cmd, t_token *head)
{
	t_redir *new;
	t_redir *tmp;

	if (!head->next || !head)
		return;
	tmp = cmd->redir;
	new = malloc(sizeof(t_redir));
	if (!new)
	{
		cmd->leak_flag = 1;
		return (perror("Malloc failed")); // return Success mais normal, il faut faire echouer avec -1
	}
	ft_memset(new, 0, sizeof(t_redir));

	// on dup ce qu'il y a apres la redir
	new->filename = token_to_string(head->next);
	if (!new->filename)
	{
		free(new);
		cmd->leak_flag = 1;
		return (perror("Malloc failed")); //
	}
	t_fragment *first = head->next->fragments;
	new->quote_type = (first ? first->quote_type : NO_QUOTE);
	new->next = NULL;
	append_redir(&cmd->redir, new);
}

void lst_clear_cmds(t_word **head_w, t_redir **head_r, t_cmds **head)
{
	lst_clear((void **)head_w, get_next_word, del_word);

	lst_clear((void **)head_r, get_next_redir, del_redir);
	lst_clear((void **)head, get_next_cmds, del_cmds);
}

void add_word_and_redir(t_token *head_token, t_token *end, t_cmds *cmd)
{
	while (head_token != end->next)
	{
		// cree la liste de mot
		if (head_token->type == WORD)
		{
			create_word(cmd, head_token);
		}
		// cree la liste de redir
		else if (is_redir(head_token))
		{
			create_redir(cmd, head_token);
			head_token = head_token->next;
		}
		head_token = head_token->next;
	}
}

void create_cmds(t_token *head_token, t_token *end, t_cmds **head)
{
	t_cmds *new;
	t_cmds *tmp;

	new = malloc(sizeof(t_cmds));
	if (!new)
	{
		return (perror("Malloc failed")); // return Success mais normal, il faut faire echouer avec -1
	}
	// initialise les pointeurs de cmds a NULL
	ft_memset(new, 0, sizeof(t_cmds));
	new->leak_flag = 1;
	// parcourt la chaine de la fin du precedent pipe au suivant
	add_word_and_redir(head_token, end, new);
	// initialise head
	if (!*head)
		*head = new;
	// parcourt la liste jusqu au dernier element, ajoute a la fin
	else
	{
		tmp = *head;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
	print_elements_cmds(new->words, new->redir); // a supprimer plus tard
	lst_clear_cmds(&new->words, &new->redir, head);
}

#include <readline/history.h>
#include <readline/readline.h>
#include <signal.h>
#include <stddef.h>
#include <sys/types.h>
#include <unistd.h>

/*
	Handle CTRL C
*/
void	sigint_handler(int signal)
{
	// void juste pour utiliser signal pour les flags
	(void)signal;
	write(1, "\n", 1);
	// remplace la ligne actuelle par "", 1 pour supp l historique, 0 conserver
	rl_replace_line("", 0);
	// informe realine que l on passe a une nouvelle ligne
	rl_on_new_line();
	// rappel le prompt
	rl_redisplay();
}

/*
	sigaction struct:
		struct sigaction {
			void (*sa_handler)(int);
			sigset_t sa_mask;
			int sa_flags;
		};
		- sa_handler: pointeur sur la fonction de gestion du signal
		- sigemptyset: initialise le masque de signaux a bloquer,
			en gros on ne bloque aucun signal
		- sa_flags: flags pour la gestion du signal,
			SA_RESTART pour redemarrer les appels systeme interrompus
		- sigaction: Quand SIGINT arrive,
			appelle sigint_handler et applique les options (sa_mask, sa_flags)
		- signal: ignore SIGQUIT
*/

void	set_sig_action(void)
{
	struct sigaction act;

	act.sa_handler = &sigint_handler;
	sigemptyset(&act.sa_mask);
	act.sa_flags = SA_RESTART;
	sigaction(SIGINT, &act, NULL);
	signal(SIGQUIT, SIG_IGN);
}
#include "minishell.h"

void print_elements_cmds(t_word *head_w, t_redir *head_r)
{
	t_word *tmp_w;
	t_redir *tmp_r;
	tmp_w = head_w;
	while (tmp_w != NULL)
	{
		ft_printf("Create word: %s quote_type %i\n", tmp_w->word, tmp_w->quote_type);
		tmp_w = tmp_w->next;
	}
	tmp_r = head_r;
	while (tmp_r != NULL)
	{
		ft_printf("Create redir: type %s | value: %s | quote_type %i\n",
				  get_token_type_str(tmp_r->type), tmp_r->filename, tmp_r->quote_type);
		tmp_r = tmp_r->next;
	}
}
#include "minishell.h"

void free_fragments(t_fragment *frag)
{
	t_fragment *tmp;
	while (frag)
	{
		tmp = frag->next;
		free(frag->text);
		free(frag);
		frag = tmp;
	}
}

void del_token(void *content)
{
	t_token *token = (t_token *)content;
	free_fragments(token->fragments);
	free(token);
}


void token_clear(t_token **lst, void (*del)(void *))
{
	t_token *tmp;

	if (!lst || !del)
		return;
	while (*lst)
	{
		tmp = (*lst)->next;
		del(*lst);
		*lst = tmp;
	}
	*lst = NULL;
}

void ft_create_token(t_token_type type, t_fragment *fragments, t_token **head)
{
	t_token *new = malloc(sizeof(t_token));
	if (!new)
		return;
	new->type = type;
	new->fragments = fragments;
	new->index = 0;
	new->next = NULL;

	if (!*head)
		*head = new;
	else
	{
		t_token *tmp = *head;
		while (tmp->next)
			tmp = tmp->next;
		tmp->next = new;
	}
}



void ft_print_tokens(t_token *head)
{
	while (head)
	{
		ft_printf("Token: Type = %d, Value = %s \n", head->type, head->fragments);
		head = head->next;
	}
}
#include "minishell.h"

void	lst_clear(void **lst, void *(*get_next)(void *), void (*del)(void *))
{
	t_token *tmp;

	if (!lst || !*lst || !get_next || !del)
		return ;
	while (*lst)
	{
		tmp = get_next(*lst);
		del(*lst);
		*lst = tmp;
	}
	*lst = NULL;
}
#include "minishell.h"

void	del_word(void *content)
{
	t_word	*token;

	token = (t_word *)content;
	if (token->word)
		free(token->word);
	free(token);
}

void	del_redir(void *content)
{
	t_redir	*token;

	token = (t_redir *)content;
	if (token->filename)
	{
		free(token->filename);
	}
	free(token);
}

void	del_cmds(void *content)
{
	t_cmds	*node;

	node = (t_cmds *)content;
	free(node);
}

#include "libft.h"
#include "minishell.h"

// renvoie  positif si c == quelque chose
int	is_token(char c)
{
	return (c == '|' || c == '<' || c == '>');
}

int	is_separator(char c)
{
	return (ft_isspace(c) || is_token(c));
}



#include "minishell.h"

const char	*get_token_type_str(t_token_type type)
{
	if (type == WORD)
		return ("WORD");
	if (type == PIPE)
		return ("PIPE");
	if (type == REDIR_IN)
		return ("REDIR_IN");
	if (type == REDIR_OUT)
		return ("REDIR_OUT");
	if (type == APPEND)
		return ("APPEND");
	if (type == HEREDOC)
		return ("HEREDOC");
	return ("UNKNOWN");
}

int	is_redir(t_token *head_token)
{
	return (head_token->type == REDIR_IN || head_token->type == REDIR_OUT
		|| head_token->type == APPEND || head_token->type == HEREDOC);
}